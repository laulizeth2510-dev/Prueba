<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Pascalina</title>
    <!-- Cargar Tailwind CSS para clases de utilidad -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos generales del cuerpo */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Fondo claro */
        }
        
        /* Contenedor principal de la calculadora */
        .pascaline-frame {
            padding: 0px; 
            border-radius: 15px;
            display: flex;
            justify-content: center; 
            align-items: flex-start;
            position: relative; 
            gap: 0; 
            margin-top: 0px; 
        }

        /* Contenedor de la Rueda/Columna de Dígito */
        .digit-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 130px; 
            position: relative;
            margin-right: 3px; 
        }
        .digit-column:last-child {
            margin-right: 0;
        }

        /* Contenedor de los engranajes */
        .gear-system {
            height: 130px; 
            width: 130px; 
            position: relative;
            /* Se mantiene subido un poco más el engranaje principal */
            margin-top: -25px; 
            z-index: 1; 
        }

        /* Estilo para el engranaje. Usamos JS para la animación suave. */
        .gear-svg {
            position: absolute;
            transform-origin: center;
        }

        /* Engranaje principal */
        .main-gear {
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Botón de incremento (Simula la entrada del usuario) */
        .increment-button {
            width: 100px;
            padding: 8px 0;
            border-radius: 4px;
            font-weight: bold;
            position: relative;
            z-index: 5; 
            /* Espacio visual entre la parte visible del engranaje y el botón */
            margin-top: 15px; 
        }

        /* Caja negra de visualización del dígito */
        .current-value-display {
            width: 100px;
            margin-top: 8px; /* Espacio entre el botón verde y la caja negra */
            padding: 4px 0;
            background-color: #1F2937; /* Gris muy oscuro/Negro */
            color: #FFEB3B; /* Texto Amarillo/Dorado para contraste */
            font-size: 1.5rem;
            font-weight: extra-bold;
            text-align: center;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            /* Altura aproximada de 44px para alineamiento */
            height: 44px;
        }

        /* NUEVO ESTILO: Columna para el separador decimal */
        .decimal-separator {
            width: 15px; /* Anchura mínima para el punto */
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            margin-right: 3px; 
        }

        /* Contenedor del punto/coma para asegurar su posición */
        .decimal-point-container {
            width: 100%;
            height: 44px; /* Misma altura que la caja negra */
            display: flex;
            align-items: center; /* Centrado vertical */
            justify-content: center; /* Centrado horizontal */
            margin-top: 8px; /* Mismo margen que la caja negra */
        }
        
        /* El texto del punto/coma */
        .decimal-point-text {
            font-size: 2.5rem; /* Tamaño grande para la coma */
            line-height: 1;
            color: #1F2937; /* Color oscuro */
            font-weight: 900;
            /* Ajuste vertical para que parezca un punto decimal en la línea base */
            transform: translateY(4px); 
        }


        /* Wrapper del Engranaje de Acarreo - AJUSTE DE TANGENCIA Y CAPA */
        .carry-gear-wrapper {
            position: absolute;
            height: 130px;
            width: 130px;
            /* El centro del engranaje gris debe estar 130px arriba del centro del engranaje amarillo (2 radios). */
            top: -130px; 
            /* Z-index 2 para que el engranaje gris (acarreo) siempre esté visualmente por encima del engranaje principal amarillo */
            z-index: 2; 
        }
        
        /* Ventana de Lectura (Pequeño punto fijo sobre la rueda) */
        .fixed-reading-dot {
            position: absolute;
            /* Centrado horizontalmente */
            left: 50%;
            transform: translateX(-50%);
            /* AJUSTE: Mueve el punto 20px hacia arriba para compensar el movimiento del engranaje */
            top: -10px; 
            
            width: 4px;
            height: 4px;
            background-color: #D32F2F; /* Punto rojo de referencia */
            border-radius: 50%;
            border: 1px solid #000;
            z-index: 10; /* Siempre encima del engranaje */
        }

        /* Indicador de Acarreo (mantiene el estilo) */
        .carry-indicator {
            position: absolute;
            /* Se ajusta también el indicador de acarreo para subir con el resto de la columna */
            top: -10px; 
            right: 0px;
            font-size: 0.8rem;
            font-weight: bold;
            color: #FFEB3B; 
            background-color: #D32F2F; 
            padding: 2px 5px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }

        .carry-active {
            opacity: 1;
            animation: flash 0.4s 2 alternate;
        }

        @keyframes flash {
            from { opacity: 1; transform: scale(1.1); }
            to { opacity: 0.8; transform: scale(1.0); }
        }
        
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 font-sans">

    <div class="w-full max-w-6xl p-8 md:p-12 mt-8">
        <h1 class="text-4xl font-extrabold text-gray-800 text-center mb-40">
            Simulador de Pascalina Mecanico
        </h1>
        
        <!-- Contenedor del marco de la Pascalina -->
        <div id="pascalineContainer" class="pascaline-frame">
            <!-- Las columnas de dígitos, los engranajes principales y los engranajes de acarreo se insertarán aquí por JavaScript -->
        </div>

        <!-- Controles y Resultados -->
        <div class="mt-8 flex flex-col md:flex-row justify-center items-center space-y-4 md:space-y-0 md:space-x-4 w-full">
            <div class="bg-white p-4 rounded-lg shadow w-full md:w-1/4">
                <h3 class="text-xl font-semibold text-gray-800 mb-2 text-center">Total Acumulado</h3>
                <!-- Aquí se muestra el valor total de las ruedas. -->
                <p id="totalDisplay" class="text-4xl font-black text-red-600 bg-gray-50 p-3 rounded text-center border-2 border-red-300">0,000</p>
            </div>
            
            <button 
                onclick="clearPascaline()" 
                class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg transition duration-150 shadow-lg w-full md:w-auto"
            >
                Restablecer (C)
            </button>
            <!-- Botón de unidades mínimas, Milésimas (Index 0) con etiqueta numérica -->
            <button 
                onclick="addUnit(0, 1)" 
                class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg transition duration-150 shadow-lg w-full md:w-auto"
            >
                Añadir +0,001 (Milésimas)
            </button>
        </div>

    </div>

    <script>
        // --- Configuración y Estado ---
        const NUM_WHEELS = 6; // Número de ruedas/dígitos
        // Mapeo de índices (de derecha a izquierda, menor a mayor valor):
        // 0: Milésimas (0.001), 1: Centésimas (0.01), 2: Décimas (0.1), 3: Unidades (1), 4: Decenas (10), 5: Centenas (100)
        let wheelValues = Array(NUM_WHEELS).fill(0); // Valor de cada rueda (0-9). Almacena el acumulado.
        // [currentRotation (visual), targetRotation (meta)] en grados
        let wheelRotations = Array(NUM_WHEELS).fill().map(() => [0, 0]); 
        // Estado para los engranajes de acarreo: [currentRotation, targetRotation]
        let carryRotations = Array(NUM_WHEELS - 1).fill().map(() => [0, 0]); 
        
        const ROTATION_PER_UNIT = 36; // 360 grados / 10 dígitos
        const GEAR_SIZE = 130; 
        const ANIMATION_DURATION = 350; 
        const COLUMN_WIDTH_PLUS_GAP = 133; // Ancho de columna (130) + margen (3)
        const CARRY_TOOTH_INDEX = 5; // Diente largo en la posición 5 del engranaje de acarreo

        // --- DOM Elements ---
        const pascalineContainer = document.getElementById('pascalineContainer');
        const totalDisplay = document.getElementById('totalDisplay');

        // Mapa para rastrear los IDs de los frames de animación
        let animationFrames = {};
        let carryAnimationFrames = {};

        // --- Utilidades SVG ---

        /**
         * Genera el SVG de un engranaje, incluyendo los dígitos en su superficie si es el principal.
         */
        function createGearSVG(id, rotation, isCarryGear = false) {
            const teeth = 10;
            const size = GEAR_SIZE;
            const color = isCarryGear ? "#BCAAA4" : "#FFD700"; 
            const strokeColor = isCarryGear ? "#795548" : "#A0522D"; 
            
            const toothAngle = 360 / teeth; 
            
            const toothWidth = 5; 
            const toothHeight = 10;
            const longToothHeight = 25; 
            
            const radius = size / 2 - 5; 
            const centerX = size / 2;
            const centerY = size / 2;
            
            const textRadius = radius - 20; 
            const DIGIT_VERTICAL_SHIFT = 0; 
            const textOrbitCenterY = centerY + DIGIT_VERTICAL_SHIFT;
            const VERTICAL_OFFSET_FOR_CENTERING = -2;
            const FONT_SIZE = 18;
            const AXLE_RADIUS = 2.5; 

            let markup = `
                <svg class="gear-svg ${isCarryGear ? 'carry-gear' : 'main-gear'}" 
                     id="${id}" 
                     width="${size}" height="${size}" 
                     viewBox="0 0 ${size} ${size}" 
                     style="transform: rotate(${rotation}deg);"> 
                    
                    <!-- Círculo principal del engranaje -->
                    <circle cx="${centerX}" cy="${centerY}" r="${radius}" fill="${color}" stroke="${strokeColor}" stroke-width="2"/>
                    <!-- Eje central -->
                    <circle cx="${centerX}" cy="${centerY}" r="${AXLE_RADIUS}" fill="#333" stroke="#333" stroke-width="2"/>
                    
                    <!-- Dientes de Engranaje (Rectángulos simples) -->
                    ${[...Array(teeth).keys()].map(j => {
                        const isLongTooth = isCarryGear && j === CARRY_TOOTH_INDEX;
                        const height = isLongTooth ? longToothHeight : toothHeight;

                        return `
                            <rect x="${centerX - toothWidth / 2}" y="${centerY - radius}" 
                                width="${toothWidth}" 
                                height="${height}" 
                                fill="${strokeColor}" 
                                rx="1" ry="1"
                                transform="translate(${centerX}, ${centerY}) rotate(${j * toothAngle}) translate(-${centerX}, -${centerY})"/>
                        `;
                    }).join('')}
                    
                    <!-- DIGITOS EN LA RUEDA (Solo si no es engranaje de acarreo) -->
                    ${isCarryGear ? '' : [...Array(teeth).keys()].map(d => {
                        const PLACEMENT_ANGLE_ZERO = 270; 
                        const displayAngleDeg = PLACEMENT_ANGLE_ZERO - (d * ROTATION_PER_UNIT); 
                        const angleRad = displayAngleDeg * (Math.PI / 180); 
                        
                        const textX = centerX + textRadius * Math.cos(angleRad);
                        const textY = textOrbitCenterY + textRadius * Math.sin(angleRad);
                        
                        const rotationCompensation = -rotation;
                        
                        return `
                            <text x="${textX}" y="${textY + VERTICAL_OFFSET_FOR_CENTERING}" 
                                text-anchor="middle" 
                                dominant-baseline="middle" 
                                fill="#1F2937" 
                                font-size="${FONT_SIZE}" 
                                font-weight="bold"
                                transform="rotate(${rotationCompensation}, ${textX}, ${textY + VERTICAL_OFFSET_FOR_CENTERING})">
                                ${d}
                            </text>
                        `;
                    }).join('')}
                </svg>
            `;
            return markup;
        }

        /**
         * Actualiza el display de lectura digital de una columna específica.
         */
        function updateColumnDisplay(index) {
            const displayElement = document.getElementById(`value-display-${index}`);
            if (displayElement) {
                // El valor visible es el acumulado modulo 10
                const visibleDigit = wheelValues[index] % 10;
                displayElement.textContent = visibleDigit;
            }
        }
        
        /**
         * Inicializa la estructura de la Pascalina.
         */
        function initializeWheels() {
            // Cancelar animaciones antes de reiniciar el DOM
            Object.values(animationFrames).forEach(frameId => cancelAnimationFrame(frameId));
            Object.values(carryAnimationFrames).forEach(frameId => cancelAnimationFrame(frameId));
            animationFrames = {};
            carryAnimationFrames = {};
            
            pascalineContainer.innerHTML = ''; 
            
            const columnsContainer = document.createElement('div');
            columnsContainer.className = 'flex';

            // Mapeo de valores de posición para el botón:
            const positionValues = [
                "+0,001 (Milésimas)",
                "+0,01 (Centésimas)",
                "+0,1 (Décimas)",
                "+1 (Unidades)",
                "+10 (Decenas)",
                "+100 (Centenas)"
            ];

            // 1. Renderiza las ruedas de izquierda (mayor valor, Centenas) a derecha (menor valor, Milésimas)
            for (let i = NUM_WHEELS - 1; i >= 0; i--) { 
                
                // --- Separador Decimal (entre Unidades i=3 y Décimas i=2) ---
                if (i === 2) {
                    const separator = document.createElement('div');
                    separator.className = 'decimal-separator';
                    separator.innerHTML = `
                        <!-- Placeholder para igualar el espacio del botón y engranaje (aprox 172px) -->
                        <div style="height: 172px; width: 100%;"></div> 
                        
                        <!-- El contenedor del punto/coma, con la misma altura que la caja negra (44px) -->
                        <div class="decimal-point-container">
                            <span class="decimal-point-text">,</span> 
                        </div>
                    `;
                    columnsContainer.appendChild(separator);
                }
                
                const column = document.createElement('div');
                column.className = 'digit-column';
                
                // --- Contenedor del Sistema de Engranajes ---
                const gearSystem = document.createElement('div');
                gearSystem.id = `gear-system-${i}`;
                gearSystem.className = 'gear-system';
                
                // Generar Engranaje Principal (con dígitos)
                const initialVisualRotation = 180;
                wheelRotations[i][0] = initialVisualRotation;
                wheelRotations[i][1] = initialVisualRotation;

                const mainGear = createGearSVG(`main-gear-${i}`, wheelRotations[i][0]);
                gearSystem.innerHTML += mainGear;
                column.appendChild(gearSystem); 
                
                // --- Indicador de lectura fijo (punto rojo) ---
                const readingDot = document.createElement('div');
                readingDot.className = 'fixed-reading-dot';
                column.appendChild(readingDot); 
                
                // --- Botón de Incremento (VERDE) ---
                const button = document.createElement('button');
                button.className = 'increment-button bg-green-500 hover:bg-green-600 text-white font-semibold rounded-lg shadow-md';
                
                button.textContent = positionValues[i];
                button.onclick = () => addUnit(i, 1); 
                column.appendChild(button); 
                
                // --- Display de Valor Actual (NEGRO) ---
                const valueDisplay = document.createElement('div');
                valueDisplay.id = `value-display-${i}`;
                valueDisplay.className = 'current-value-display';
                
                // Asegurar que el valor inicial '0' se muestre
                valueDisplay.textContent = (wheelValues[i] % 10).toString(); 
                
                column.appendChild(valueDisplay);

                // --- Indicador de Acarreo ---
                const carryIndicator = document.createElement('span');
                carryIndicator.id = `carry-${i}`;
                carryIndicator.className = 'carry-indicator';
                carryIndicator.textContent = 'ACARREO';
                column.appendChild(carryIndicator);
                
                columnsContainer.appendChild(column);
                
                // 2. Insertar Engranaje de Acarreo (gris)
                if (i > 0) {
                    const carryIndex = i - 1; 
                    const halfGearSize = GEAR_SIZE / 2; 
                    const gapWidth = COLUMN_WIDTH_PLUS_GAP - GEAR_SIZE; 
                    
                    const carryGearWrapper = document.createElement('div');
                    carryGearWrapper.id = `carry-gear-wrapper-${carryIndex}`;
                    carryGearWrapper.className = 'carry-gear-wrapper';
                    
                    const numColumnsLeft = NUM_WHEELS - i; 
                    const startOfGap = (numColumnsLeft * COLUMN_WIDTH_PLUS_GAP) - gapWidth;
                    const centerOfGap = startOfGap + gapWidth / 2; 
                    let carryGearLeft = centerOfGap - halfGearSize; 

                    const SHIFT_LEFT = 4; 
                    carryGearLeft -= SHIFT_LEFT; 

                    const carryGearSVG = createGearSVG(`carry-gear-${carryIndex}`, carryRotations[carryIndex][0], true);
                    carryGearWrapper.innerHTML = carryGearSVG;
                    
                    carryGearWrapper.style.left = `${carryGearLeft}px`; 

                    pascalineContainer.appendChild(carryGearWrapper);
                }
            }
            
            pascalineContainer.appendChild(columnsContainer);
        }
        
        // --- Lógica de Animación y Funciones ---

        /**
         * Anima la rotación de un engranaje principal (y sus dígitos).
         */
        function animateRotation(index, startTime) {
            const startRotation = wheelRotations[index][0]; 
            const targetRotation = wheelRotations[index][1]; 
            const elapsedTime = performance.now() - startTime;
            
            let progress = Math.min(1, elapsedTime / ANIMATION_DURATION);
            
            progress = (progress < 0.5) ? (4 * progress * progress * progress) : (1 - Math.pow(-2 * progress + 2, 4) / 2);

            const currentRotation = startRotation + (targetRotation - startRotation) * progress;
            wheelRotations[index][0] = currentRotation; 

            // 1. Actualiza la rotación del SVG principal
            const gearElement = document.getElementById(`main-gear-${index}`);
            if (gearElement) {
                gearElement.style.transform = `rotate(${currentRotation}deg)`;
                
                // 2. Actualiza la rotación compensatoria de los dígitos
                const textElements = gearElement.querySelectorAll('text');
                const rotationCompensation = -currentRotation; 
                const VERTICAL_OFFSET_FOR_CENTERING = -2;
                
                textElements.forEach(text => {
                    const x = parseFloat(text.getAttribute('x'));
                    const y = parseFloat(text.getAttribute('y')); 
                    text.setAttribute('transform', `rotate(${rotationCompensation}, ${x}, ${y})`);
                });
            }


            if (elapsedTime < ANIMATION_DURATION) {
                animationFrames[index] = requestAnimationFrame(() => animateRotation(index, startTime));
            } else {
                // Finaliza la animación y establece la rotación final
                wheelRotations[index][0] = targetRotation;
                delete animationFrames[index];
                
                // Asegurar el renderizado final
                if (gearElement) {
                    gearElement.style.transform = `rotate(${targetRotation}deg)`;
                    const textElements = gearElement.querySelectorAll('text');
                    const finalRotationCompensation = -targetRotation;
                    const VERTICAL_OFFSET_FOR_CENTERING = -2;
                    textElements.forEach(text => {
                        const x = parseFloat(text.getAttribute('x'));
                        const y = parseFloat(text.getAttribute('y'));
                        text.setAttribute('transform', `rotate(${finalRotationCompensation}, ${x}, ${y})`);
                    });
                }
            }
        }
        
        /**
         * Anima la rotación de un engranaje de acarreo.
         */
        function animateCarryGear(index, startTime) {
            const startRotation = carryRotations[index][0]; 
            const targetRotation = carryRotations[index][1]; 
            const elapsedTime = performance.now() - startTime;
            
            let progress = Math.min(1, elapsedTime / ANIMATION_DURATION);
            
            progress = (progress < 0.5) ? (4 * progress * progress * progress) : (1 - Math.pow(-2 * progress + 2, 4) / 2);

            const currentRotation = startRotation + (targetRotation - startRotation) * progress;
            carryRotations[index][0] = currentRotation; 

            const carryGearElement = document.getElementById(`carry-gear-${index}`);
            if (carryGearElement) {
                carryGearElement.style.transform = `rotate(${currentRotation}deg)`;
            }

            if (elapsedTime < ANIMATION_DURATION) {
                carryAnimationFrames[index] = requestAnimationFrame(() => animateCarryGear(index, startTime));
            } else {
                carryRotations[index][0] = targetRotation;
                delete carryAnimationFrames[index];
                
                if (carryGearElement) {
                    carryGearElement.style.transform = `rotate(${targetRotation}deg)`;
                }
            }
        }

        /**
         * Muestra una animación de acarreo en el indicador.
         */
        function triggerCarryAnimation(index) {
            const receiverIndex = index + 1;
            if (receiverIndex < NUM_WHEELS) {
                const carryIndicator = document.getElementById(`carry-${receiverIndex}`);
                if (carryIndicator) {
                    carryIndicator.classList.add('carry-active');
                    setTimeout(() => {
                        carryIndicator.classList.remove('carry-active');
                    }, 800);
                }
            }
        }


        /**
         * Maneja la adición de una unidad al índice de rueda especificado e implementa el acarreo.
         */
        function addUnit(index, value = 1) {
            if (index >= NUM_WHEELS || index < 0) return;

            // 1. Aplica la rotación visual al engranaje principal 
            const rotationChange = value * ROTATION_PER_UNIT;
            wheelRotations[index][1] += rotationChange; 
            
            // 2. Comprueba si se va a producir un acarreo ANTES de cambiar el dígito.
            const currentValue = wheelValues[index] % 10;
            const willCarry = currentValue === 9 && value === 1;
            
            // 3. Añade el valor al dígito de la rueda actual (acumulado)
            wheelValues[index] += value;
            
            // 4. Inicia la animación de rotación del engranaje principal
            if (!animationFrames[index]) {
                animateRotation(index, performance.now());
            }

            // LÓGICA DE ACOPLAMIENTO (Mover Engranaje Gris)
            if (index < NUM_WHEELS - 1) {
                const carryGearIndex = index; 
                carryRotations[carryGearIndex][1] -= rotationChange;

                if (!carryAnimationFrames[carryGearIndex]) {
                    carryRotations[carryGearIndex][0] = carryRotations[carryGearIndex][0] || 0;
                    animateCarryGear(carryGearIndex, performance.now());
                }
            }
            
            // 5. Lógica del Engranaje de Acarreo (para el acarreo real 9->0)
            if (willCarry) {
                triggerCarryAnimation(index);
                addUnit(index + 1, 1);
            }
            
            // 6. Actualiza el total y el display de la columna actual
            updateTotalDisplay();
            updateColumnDisplay(index);
        }
        
        /**
         * Calcula el valor total de las ruedas y lo muestra, ahora con tres decimales (milésimas).
         */
        function updateTotalDisplay() {
            // Mapeo de índices (Centenas a Milésimas): 5 4 3 , 2 1 0

            // 1. Construye la parte entera (R5 R4 R3)
            let integerPartStr = '';
            for (let i = NUM_WHEELS - 1; i >= 3; i--) {
                // Usa el valor del dígito actual (módulo 10)
                integerPartStr += (wheelValues[i] % 10).toString();
            }
            
            // 2. Construye la parte decimal (R2 R1 R0)
            let decimalPartStr = '';
            for (let i = 2; i >= 0; i--) {
                decimalPartStr += (wheelValues[i] % 10).toString();
            }

            // Convertir la parte entera a número para formato de miles
            let integerValue = parseInt(integerPartStr || '0', 10);
            
            // Formatear la parte entera usando el estándar 'es-ES' (punto como separador de miles)
            let formattedInteger = integerValue.toLocaleString('es-ES', { 
                minimumIntegerDigits: 1, 
                useGrouping: true 
            });
            
            // 3. Combinar con el separador decimal (coma para es-ES)
            let paddedDecimalPart = decimalPartStr.padEnd(3, '0').slice(0, 3);
            let totalString = `${formattedInteger},${paddedDecimalPart}`;

            totalDisplay.textContent = totalString;
        }


        /**
         * Restablece la Pascalina a cero.
         */
        function clearPascaline() {
            wheelValues = Array(NUM_WHEELS).fill(0);
            
            // Restablecer rotaciones a la posición inicial (180 grados)
            const initialVisualRotation = 180;
            wheelRotations = Array(NUM_WHEELS).fill().map(() => [initialVisualRotation, initialVisualRotation]); 
            carryRotations = Array(NUM_WHEELS - 1).fill().map(() => [0, 0]); 
            
            // Reinicializa la estructura, lo que recrea los elementos y establece los '0'
            initializeWheels(); 
            updateTotalDisplay();
        }

        // --- Inicialización ---
        window.onload = function() {
            // Establece las rotaciones iniciales antes de la inicialización completa
            const initialVisualRotation = 180;
            wheelRotations = Array(NUM_WHEELS).fill().map(() => [initialVisualRotation, initialVisualRotation]); 
            
            initializeWheels(); 
            updateTotalDisplay();
        };
    </script>
</body>
</html>
